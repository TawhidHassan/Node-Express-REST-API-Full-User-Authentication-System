let Schema,model,compare,hash,SECRET,randomBytes,sign,pick;_924‍.x([["default",()=>_924‍.o]]);_924‍.w("mongoose",[["Schema",["Schema"],function(v){Schema=v}],["model",["model"],function(v){model=v}]]);_924‍.w("bcryptjs",[["compare",["compare"],function(v){compare=v}],["hash",["hash"],function(v){hash=v}]]);_924‍.w("../constants",[["SECRET",["SECRET"],function(v){SECRET=v}]]);_924‍.w("crypto",[["randomBytes",["randomBytes"],function(v){randomBytes=v}]]);_924‍.w("jsonwebtoken",[["sign",["sign"],function(v){sign=v}]]);_924‍.w("lodash",[["pick",["pick"],function(v){pick=v}]]);







const UserSchema = new Schema(
    {
        name: {
            type: String,
            required: true,
          },
          username: {
            type: String,
            required: true,
          },
          email: {
            type: String,
            required: true,
          },
          password: {
            type: String,
            required: true,
          },
          verified: {
            type: Boolean,
            default: false,
          },
          verificationCode: {
            type: String,
            required: false,
          },
          resetPasswordToken: {
            type: String,
            required: false,
          },
          resetPasswordExpiresIn: {
            type: Date,
            required: false,
          },
        },
        { timestamps: true }
);


//pre hook use for call function after call the crate query or update query
UserSchema.pre("save", async function (next) {
    let user = this;
    if (!user.isModified("password")) return next();
    user.password = await hash(user.password, 10);
    next();
  });

  UserSchema.methods.comparePassword = async function (password) {
    return await compare(password, this.password);
  };

  UserSchema.methods.generateJWT = async function () {
    let payload = {
      username: this.username,
      email: this.email,
      name: this.name,
      id: this._id,
    };
    return await sign(payload, SECRET, { expiresIn: "1 day" });
  };

  UserSchema.methods.generatePasswordReset = function () {
    this.resetPasswordExpiresIn = Date.now() + 36000000;
    this.resetPasswordToken = randomBytes(20).toString("hex");
  };
  
  //that make a custom object against main schema
  UserSchema.methods.getUserInfo = function () {
    return pick(this, ["_id", "username", "email", "name","password"]);
  };
  
  const User = model("users", UserSchema);
  _924‍.d(User);